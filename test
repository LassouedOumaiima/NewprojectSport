package fr.ca.cats.p1354.s3601.svcllm.controller;


import fr.ca.cats.p0070.s1889.logging.service.Logger;
import fr.ca.cats.p0070.s1889.logging.service.LoggerService;
import fr.ca.cats.p1354.s3601.svcllm.model.*;
import fr.ca.cats.p1354.s3601.svcllm.service.*;
import fr.ca.cats.p1354.s3601.svcllm.service.impl.ConsumerKafkaServiceImpl;
import io.swagger.v3.oas.annotations.Hidden;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(value = "/")
@Tag(name = "TraitementSuggestionReponse")
public class SvcllmController  {

	private static final Logger LOGGER = LoggerService.getLogger(SvcllmController.class);

	ConsumerKafkaServiceImpl consumer;

	ProducerKafkaService producer;

	LLMAccessService llmAccessService;

	@Value("${POLL_DURATION_MS}")
	String pollDurationMS ;

	@Value("${url.subscription}")
	String urlSubscription ;

	@Value("${secretkey}")
	String secretkey ;

	/*Proxy credentials */
	@Value("${proxy.host}")
	String hostname ;

	@Value("${proxy.port}")
	int port ;

	@Value("${proxy.userName}")
	String username ;

	@Value("${proxy.userPassword}")
	char[] password ;

	ConsumerKafkaService consumerKafkaService;

	SvcllmService svcllmService ;

	@Autowired
	public SvcllmController(ConsumerKafkaServiceImpl consumer, ProducerKafkaService producer, LLMAccessService llmAccessService, ConsumerKafkaService consumerKafkaService, SvcllmService svcllmService) {
		this.consumer = consumer;
		this.producer = producer;
		this.llmAccessService = llmAccessService;
		this.consumerKafkaService = consumerKafkaService;
		this.svcllmService = svcllmService;
	}

	@PostConstruct
	protected void startThread() {
		consumer.setIsActiveLocal(true);
		llmAccessService.buildProxy(hostname, port, username, password);
		this.svcllmControllerThread.start();
	}

	protected final Thread svcllmControllerThread = new Thread(() -> {
		try {
			LOGGER.info("IN new Thread() -- Print value of isActive :" + consumer.getIsActiveLocal());
			consumerKafkaService.scheduleStart(consumer);
			LOGGER.info("*** new Thread(): leaving thread, isActive :" + consumer.getIsActiveLocal());
		} catch (Exception e) {
			LOGGER.error("*** new Thread(): Exception= " +e.getMessage()+"\n");
		}
	});

	@Hidden
	@PostMapping("consumerStart")
	public ResponseEntity <String> start() {
		String messageStatus = null;
		ResponseEntity responseEntity = null;
		try {
			responseEntity = consumerKafkaService.start(consumer);
			LOGGER.info("\n***{ \"action start\" : \"ok\" }");
		} catch (Exception e) {
			messageStatus = "\n***{ \"action start\" : \"KO\" , \"Exception\" : "+e.getMessage()+"}";
			responseEntity = ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(messageStatus);
			LOGGER.error(messageStatus);
		}
		return responseEntity;
	}

	@Hidden
	@PostMapping("consumerStop")
	public String stop() {
		String message = null;
		try {
			consumer.scheduleStopLocal();
			message = "\n*** stop(): isActive= " + consumer.getIsActiveLocal()+"\n";
			LOGGER.info(message);
		} catch (Exception e) {
			LOGGER.error( "\n*** stop(): Exception= \n"+e.getMessage()+"\n");
		}
		return message;
	}

	/* Methode pour récupérer des prompts à partir de l'API Python */
	@Hidden
	@PostMapping(value = "prompt_builder")
	public Chat promptBuilder(@RequestBody DemandeSuggestionEmails prompt) {
		Chat chat = null;
		try {
			chat = svcllmService.promptBuilder(prompt);
		} catch(Exception ex) {
			LOGGER.error("\n***Erreur dans la recupération des prompts a partir de l'API Python  : {} \n", ex.getMessage());
		}
 		return chat ;
	}

}
