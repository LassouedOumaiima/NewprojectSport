package fr.ca.cats.p1354.s3600.svcdem.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class AESUtilTest {

    @Mock
    private CipherAESGCMService cipherAESGCMService;

    @InjectMocks
    private AESUtil aesUtil;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testDecryptSuccessful() throws Exception {
        // Given a valid encrypted text and corresponding plaintext
        String encryptedText = "validEncryptedText"; // replace with a valid Base64 encoded string
        String expectedPlaintext = "decryptedText";

        // Mock the behavior of cipherAESGCMService
        when(cipherAESGCMService.decrypt(encryptedText)).thenReturn(expectedPlaintext);

        // When decrypt is called
        String result = aesUtil.decrypt(encryptedText);

        // Then it should return the expected plaintext
        assertEquals(expectedPlaintext, result);
        verify(cipherAESGCMService, times(1)).decrypt(encryptedText);
    }

    @Test
    void testDecryptWithException() throws Exception {
        // Given an invalid encrypted text
        String invalidEncryptedText = "invalidEncryptedText"; // replace with an invalid string

        // Mock the behavior to throw an exception when decrypt is called
        when(cipherAESGCMService.decrypt(invalidEncryptedText)).thenThrow(new Exception("Decryption error"));

        // When decrypt is called
        String result = aesUtil.decrypt(invalidEncryptedText);

        // Then it should return an error message
        assertTrue(result.startsWith("Decryption failed:"));
        verify(cipherAESGCMService, times(1)).decrypt(invalidEncryptedText);
    }
}
