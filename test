package fr.ca.cats.p1354.s3600.svcdem.service;

import fr.ca.cats.p0070.s1889.logging.service.Logger;
import fr.ca.cats.p0070.s1889.logging.service.LoggerService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import jakarta.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;

/**
 * Classe de Service de gestion des algorithmes de cryptage
 */
@Service
public class CipherAESGCMService {

	@Value("${secretkey}") 
	String secretkey ;

	private static final Logger LOGGER = LoggerService.getLogger(CipherAESGCMService.class);
	private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int IV_SIZE  = 12; // 96 bits
    private static final int TAG_SIZE = 128; // 128 bits
    private static SecretKey key = null;
    private static Cipher cipher = null;
	
	@PostConstruct
    public void init() {
        try {
        	key = KeyGeneratorUtil.generateKeyFromBytes(this.secretkey.getBytes());
        	cipher = Cipher.getInstance(ALGORITHM);
        } catch (Exception e) {
            LOGGER.error("\n*** Error while initializing CipherAESGCMService {}", e.getMessage());
        } 
	}

	/**
	 * DéCrypte une chaine de caractère en appliquant un algorithme
	 * @param text Chaîne de caractères cryptée
	 * @return Chaîne de caractères décryptée
	 */
	public String decrypt(String text) throws Exception {
		byte[] decodedCiphertext = Base64.getDecoder().decode(text);
		byte[] iv = new byte[IV_SIZE];

		
		System.arraycopy(decodedCiphertext, 0, iv, 0, IV_SIZE); // Extraire l'IV
		byte[] actualCiphertext = new byte[decodedCiphertext.length - IV_SIZE];
		System.arraycopy(decodedCiphertext, IV_SIZE, actualCiphertext, 0, actualCiphertext.length);
		
		GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(TAG_SIZE, iv);
		cipher.init(Cipher.DECRYPT_MODE, key, gcmParameterSpec);
		byte[] plaintext = cipher.doFinal(actualCiphertext);
		
		return new String(plaintext, StandardCharsets.UTF_8);

	} 
}

package fr.ca.cats.p1354.s3600.svcdem.service;

import fr.ca.cats.p0070.s1889.logging.service.Logger;
import fr.ca.cats.p0070.s1889.logging.service.LoggerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * Classe de service de cryptage pour l'algorithme AES.
 */
@Service
public class AESUtil {
	
	private static final Logger LOGGER = LoggerService.getLogger(AESUtil.class);
	
	CipherAESGCMService cipherAESGCMService ;

	@Autowired
	public AESUtil() {
		this.cipherAESGCMService = cipherAESGCMService;
	}

    /**
     * Initialise un cipher et retourne la chaîne de caractère décryptée par le cipher
     * @param text Chaîne de caractères cryptée
     * @return Chaîne de caractères décryptée
     */
    public static String decrypt(String text) {
        try {
            CipherAESGCMService cipherAESGCMService = new CipherAESGCMService();
            return cipherAESGCMService.decrypt(text);
        } catch (Exception e) {
        	LOGGER.error("\n*** Error from AESUtil cannot decrypt the text {}", e.getMessage());
            return "Decryption failed: " + e.getMessage();
        }
    }
}
package fr.ca.cats.p1354.s3600.svcdem.service;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import org.springframework.stereotype.Service;

/**
 * Classe de service de gestion des clés secrète pour l'algorithme de cryptage
 */
@Service
public class KeyGeneratorUtil {
	
	private KeyGeneratorUtil() {

	}

    /**
     * Vérifie que la clé fournit respecte la bonne longueur
     * @param keyBytes Clé de cryptage
     * @return Une clé de cryptage au format AES
     */
	public static SecretKey generateKeyFromBytes(byte[] keyBytes) {
        // Ensure the byte array is exactly 32 bytes (256 bits)
        if (keyBytes.length != 32) {
            throw new IllegalArgumentException("Key must be 256 bits (32 bytes)");
        }
        // Create a SecretKey from the byte array
        return new SecretKeySpec(keyBytes, "AES");
    }
    
}
