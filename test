package fr.ca.cats.p1354.s3601.svcllm.service.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import fr.ca.cats.p0070.s1889.logging.service.Logger;
import fr.ca.cats.p0070.s1889.logging.service.LoggerService;
import fr.ca.cats.p1354.s3601.svcllm.model.AUT9Response;
import fr.ca.cats.p1354.s3601.svcllm.model.ChatRequest;
import fr.ca.cats.p1354.s3601.svcllm.model.ChatResponse;
import fr.ca.cats.p1354.s3601.svcllm.model.CredentialProxy;
import fr.ca.cats.p1354.s3601.svcllm.service.AUT9TokenService;
import fr.ca.cats.p1354.s3601.svcllm.service.LLMAccessService;
import lombok.Getter;
import lombok.Setter;
import org.apache.hc.client5.http.auth.AuthScope;
import org.apache.hc.client5.http.auth.UsernamePasswordCredentials;
import org.apache.hc.client5.http.impl.auth.BasicCredentialsProvider;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.client5.http.impl.routing.DefaultProxyRoutePlanner;
import org.apache.hc.core5.http.HttpHost;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import java.io.StringWriter;

@Service
public class LLMAccessServiceImpl implements LLMAccessService {

    private static final Logger LOGGER = LoggerService.getLogger(LLMAccessServiceImpl.class);

    protected RestTemplate restTemplateProxy;

    protected AUT9TokenService aut9TokenService;

    protected AUT9Response aut9Response;

    @Value("${endpoint_llm}")
    String endpointLlm ;

    @Setter
    @Getter
    @Value("${proxy.host}")
    String hostname ;

    @Getter
    @Setter
    @Value("${proxy.port}")
    int port ;

    @Setter
    @Getter
    @Value("${proxy.userName}")
    String username ;

    @Value("${proxy.userPassword}")
    char[] password ;

    CredentialProxy credProxy;

    @Autowired
    public LLMAccessServiceImpl(CredentialProxy credProxy, AUT9TokenService aut9TokenService){
        this.credProxy = credProxy;
        this.aut9TokenService = aut9TokenService;
    }

    private RestTemplate buildProxy(String hostname, int port, String username, char[] password) {
        BasicCredentialsProvider credsProvider = new BasicCredentialsProvider();
        credsProvider.setCredentials(
                new AuthScope(hostname, port),
                new UsernamePasswordCredentials(username, password)
        );
        HttpHost myProxy = new HttpHost(hostname, port);
        DefaultProxyRoutePlanner router = new DefaultProxyRoutePlanner(myProxy);
        CloseableHttpClient http = HttpClients.custom()
                .setDefaultCredentialsProvider(credsProvider)
                .setRoutePlanner(new DefaultProxyRoutePlanner(myProxy))
                .setRoutePlanner(router)
                .build();
        HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(http);
        restTemplateProxy = new RestTemplate(requestFactory);

        return restTemplateProxy;
    }

    /**
     * Cette méthode permet de soumettre une requête au LLM.
     */
    public ChatResponse sendToLLM(ChatRequest chatRequest, String llmPath) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        ChatResponse chatResponse = null;
        StringWriter writer = new StringWriter();
        ObjectMapper mapper = new ObjectMapper();
        aut9Response = new AUT9Response();
        /*Verifier le token et en recuperer un nouveau si necessaire */
        aut9Response = aut9TokenService.checkAUT9Token(aut9Response);
        if (aut9Response != null){
            headers.add("Authorization", "Bearer " + aut9Response.getEncryptedAccessToken());
            try {
                // Map charRequest into the writer in order to be able to print it as a String
                mapper.writeValue(writer, chatRequest);
                // Convert everything written to the StringWriter into a String
                String result = writer.toString();
                HttpEntity<ChatRequest> entity = new HttpEntity<>(chatRequest,headers);
                restTemplateProxy = buildProxy(credProxy.getHostname(), credProxy.getPort(), credProxy.getUsername(), credProxy.getPassword());
                ResponseEntity<String> response = this.restTemplateProxy.postForEntity(endpointLlm + llmPath, entity, String.class) ;
                chatResponse = mapper.readValue(response.getBody(), ChatResponse.class);
                chatResponse.setText(chatResponse.getText().replaceFirst("\\n",""));
            } catch(Exception ex) {
                LOGGER.error("\n*** ERROR: responseChat(): Exception=\n" + ex.getMessage() +  "\n");
            }
        }
        return chatResponse;
    }

}
